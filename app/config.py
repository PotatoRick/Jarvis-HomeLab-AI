"""\nConfiguration management for AI Remediation Service.\nLoads settings from environment variables with validation.\n"""\n\nfrom pydantic_settings import BaseSettings, SettingsConfigDict\nfrom pydantic import field_validator, model_validator, ValidationError\nfrom typing import Optional\nimport re\nimport sys\n\n\nclass Settings(BaseSettings):\n    \"\"\"Application settings loaded from environment variables.\"\"\"\n\n    # Application\n    app_name: str = \"AI Remediation Service\"\n    app_version: str = \"3.12.0\"\n    debug: bool = False\n\n    # API Server\n    host: str = \"0.0.0.0\"\n    port: int = 8000\n\n    # Database\n    database_url: str\n    database_pool_size: int = 10\n    database_max_overflow: int = 20\n\n    # Claude API\n    anthropic_api_key: str\n    claude_model: str = \"claude-3-5-haiku-20241022\"\n    claude_max_tokens: int = 4000\n    claude_timeout: int = 60\n\n    # SSH Configuration\n    # All hosts use consistent key path /app/ssh_key (mounted in docker-compose.yml)\n    # Override these via environment variables for your infrastructure\n    ssh_nexus_host: str = \"localhost\"\n    ssh_nexus_user: str = \"root\"\n    ssh_nexus_key_path: str = \"/app/ssh_key\"\n\n    ssh_homeassistant_host: str = \"localhost\"\n    ssh_homeassistant_user: str = \"root\"\n    ssh_homeassistant_key_path: str = \"/app/ssh_key\"\n\n    ssh_outpost_host: str = \"localhost\"\n    ssh_outpost_user: str = \"root\"\n    ssh_outpost_key_path: str = \"/app/ssh_key\"\n\n    # Skynet - where Jarvis runs, but SSH to access host filesystem\n    ssh_skynet_host: str = \"localhost\"\n    ssh_skynet_user: str = \"root\"\n    ssh_skynet_key_path: str = \"/app/ssh_key\"\n\n    ssh_timeout: int = 60\n    ssh_connection_timeout: int = 10\n\n    # Discord Webhook\n    discord_webhook_url: str\n    discord_enabled: bool = True\n\n    # Remediation Settings\n    max_attempts_per_alert: int = 3\n    attempt_window_hours: int = 2\n    command_execution_timeout: int = 60\n    maintenance_mode: bool = False\n\n    # Anti-Spam Settings (v3.1.0)\n    fingerprint_cooldown_seconds: int = 300  # 5 minutes - don't reprocess same alert\n    escalation_cooldown_hours: int = 4       # 4 hours - don't re-escalate same alert\n\n    # Security\n    webhook_auth_username: str = \"alertmanager\"\n    webhook_auth_password: str\n\n    # Logging\n    log_level: str = \"INFO\"\n    log_format: str = \"json\"\n\n    # Phase 1: Prometheus & Loki for verification and log queries\n    # Override these via environment variables for your infrastructure\n    prometheus_url: str = \"http://localhost:9090\"\n    loki_url: str = \"http://localhost:3100\"\n\n    # Verification settings\n    verification_enabled: bool = True\n    verification_max_wait_seconds: int = 120\n    verification_poll_interval: int = 10\n    verification_initial_delay: int = 10\n\n    # Phase 2: Home Assistant integration\n    # Override these via environment variables for your infrastructure\n    ha_url: str = \"http://localhost:8123\"\n    ha_supervisor_url: str = \"http://supervisor/core\"  # Supervisor API (internal to HA)\n    ha_token: Optional[str] = None  # Long-lived access token\n\n    # Phase 3: n8n workflow orchestration\n    # Override these via environment variables for your infrastructure\n    n8n_url: str = \"http://localhost:5678\"\n    n8n_api_key: Optional[str] = None  # n8n API key for workflow execution\n\n    # Phase 3: Proactive monitoring\n    proactive_monitoring_enabled: bool = True\n    proactive_check_interval: int = 300  # 5 minutes\n    disk_exhaustion_warning_hours: int = 24  # Warn if disk fills in <24h\n    cert_expiry_warning_days: int = 30  # Warn if cert expires in <30 days\n    memory_leak_threshold_mb_per_hour: float = 5.0  # Memory growth rate threshold\n\n    # Phase 5: Self-preservation settings\n    # External URL for n8n to callback to Jarvis (must be reachable from n8n host)\n    # Defaults to ssh_skynet_host:port but should be set explicitly in production\n    jarvis_external_url: Optional[str] = None  # e.g., \"http://192.168.0.13:8000\"\n    self_restart_timeout_minutes: int = 10  # Max time for n8n to poll before timeout\n    stale_handoff_cleanup_minutes: int = 30  # Auto-cleanup handoffs older than this\n\n    # Phase 6: Anomaly detection settings\n    anomaly_detection_enabled: bool = True\n    anomaly_check_interval: int = 300  # 5 minutes between checks\n    anomaly_cooldown_minutes: int = 30  # Suppress duplicate anomaly notifications\n    anomaly_z_score_warning: float = 3.0  # Z-score threshold for warning severity\n    anomaly_z_score_critical: float = 4.0  # Z-score threshold for critical severity\n\n    model_config = SettingsConfigDict(\n        env_file=\".env\",\n        env_file_encoding=\"utf-8\",\n        case_sensitive=False,\n    )\n\n    # =========================================================================\n    # HIGH-007 FIX: Pydantic validators for Phase 5 configuration\n    # =========================================================================\n\n    @field_validator('jarvis_external_url')\n    @classmethod\n    def validate_jarvis_external_url(cls, v: Optional[str]) -> Optional[str]:\n        \"\"\"\n        HIGH-001 FIX: Validate JARVIS_EXTERNAL_URL format.\n\n        Must be a valid HTTP(S) URL and cannot contain 'localhost' since\n        n8n runs on Outpost and needs to reach Jarvis on Skynet.\n        \"\"\"\n        if v is None:\n            return v\n\n        # Check URL format\n        url_pattern = re.compile(\n            r'^https?://'  # http:// or https://\n            r'(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\\.)+[A-Z]{2,6}\\.?|'  # domain\n            r'localhost|'  # localhost (will warn)\n            r'\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})'  # IP\n            r'(?::\\d+)?'  # optional port\n            r'(?:/?|[/?]\\S+)$', re.IGNORECASE\n        )\n\n        if not url_pattern.match(v):\n            raise ValueError(\n                f\"JARVIS_EXTERNAL_URL must be a valid HTTP(S) URL, got: {v}\"\n            )\n\n        # Warn about localhost (n8n on Outpost can't reach localhost)\n        # Don't error - might be valid in development\n        if 'localhost' in v.lower() or '127.0.0.1' in v:\n            import warnings\n            warnings.warn(\n                f\"JARVIS_EXTERNAL_URL contains 'localhost' ({v}). \"\n                \"This will not work if n8n runs on a different host. \"\n                \"Set to Jarvis's reachable IP (e.g., http://192.168.0.13:8000).\",\n                UserWarning\n            )\n\n        return v\n\n    @field_validator('stale_handoff_cleanup_minutes')\n    @classmethod\n    def validate_stale_handoff_cleanup(cls, v: int) -> int:\n        \"\"\"\n        Validate cleanup minutes is within reasonable bounds.\n\n        Too small: Could clean up legitimate handoffs during slow restarts\n        Too large: Old handoffs accumulate and block new restarts\n        \"\"\"\n        if v < 10:\n            raise ValueError(\n                f\"stale_handoff_cleanup_minutes must be at least 10, got: {v}. \"\n                \"Values below 10 risk cleaning up legitimate in-progress handoffs.\"\n            )\n        if v > 1440:  # 24 hours\n            raise ValueError(\n                f\"stale_handoff_cleanup_minutes must be at most 1440 (24h), got: {v}. \"\n                \"Very long cleanup periods could cause issues.\"\n            )\n        return v\n\n    @field_validator('self_restart_timeout_minutes')\n    @classmethod\n    def validate_self_restart_timeout(cls, v: int) -> int:\n        \"\"\"Validate restart timeout is reasonable.\"\"\"\n        if v < 2:\n            raise ValueError(\n                f\"self_restart_timeout_minutes must be at least 2, got: {v}. \"\n                \"Restarts need time to complete.\"\n            )\n        if v > 60:\n            raise ValueError(\n                f\"self_restart_timeout_minutes must be at most 60, got: {v}. \"\n                \"Very long timeouts suggest a problem with the restart.\"\n            )\n        return v\n\n    @field_validator('n8n_url')\n    @classmethod\n    def validate_n8n_url(cls, v: str) -> str:\n        \"\"\"Validate n8n URL format.\"\"\"\n        if not v.startswith(('http://', 'https://')):\n            raise ValueError(\n                f\"n8n_url must start with http:// or https://, got: {v}\"\n            )\n        return v.rstrip('/')  # Normalize: remove trailing slash\n\n\n# ─────────────────────────────────────────────────────────────────────────────\n# Configuration Error Handling\n# ─────────────────────────────────────────────────────────────────────────────\n\n# Descriptions for required fields (shown in error messages)\nFIELD_DESCRIPTIONS = {\n    'database_url': 'PostgreSQL connection string (e.g., postgresql://jarvis:pass@postgres-jarvis:5432/jarvis)',\n    'anthropic_api_key': 'Claude API key from console.anthropic.com (starts with sk-ant-)',\n    'discord_webhook_url': 'Discord webhook URL for notifications',\n    'webhook_auth_password': 'Password for Alertmanager webhook authentication',\n}\n\n\ndef print_config_error(missing_fields: list[str], invalid_fields: list[tuple[str, str]]) -> None:\n    \"\"\"Print a helpful error message for configuration issues.\"\"\"\n    print()\n    print(\"=\" * 79)\n    print(\" JARVIS CONFIGURATION ERROR\")\n    print(\"=\" * 79)\n    print()\n    print(\" Your configuration is incomplete or invalid. Please check your .env file.\")\n    print()\n\n    if missing_fields:\n        print(\" Missing required variables:\")\n        for field in missing_fields:\n            desc = FIELD_DESCRIPTIONS.get(field, 'Required field')\n            print(f\"   \\033[91m\u2717\\033[0m {field.upper():30} - {desc}\")\n        print()\n\n    if invalid_fields:\n        print(\" Invalid values:\")\n        for field, msg in invalid_fields:\n            print(f\"   \\033[91m\u2717\\033[0m {field.upper():30} - {msg}\")\n        print()\n\n    print(\" To fix this:\")\n    print(\"   1. Copy the example config:       cp .env.example .env\")\n    print(\"   2. Edit with your values:         nano .env\")\n    print(\"   3. Or run the setup wizard:       ./setup.sh\")\n    print()\n    print(\" Quick Start requirements:\")\n    print(\"   - DATABASE_URL and POSTGRES_PASSWORD\")\n    print(\"   - ANTHROPIC_API_KEY (from console.anthropic.com)\")\n    print(\"   - SSH_NEXUS_HOST and SSH_NEXUS_USER\")\n    print(\"   - DISCORD_WEBHOOK_URL (recommended)\")\n    print(\"   - WEBHOOK_AUTH_PASSWORD\")\n    print()\n    print(\" Documentation: https://github.com/PotatoRick/Jarvis-HomeLab-AI\")\n    print()\n    print(\"=\" * 79)\n    print()\n\n\ndef load_settings() -> Settings:\n    \"\"\"\n    Load settings with user-friendly error messages.\n\n    Instead of showing a cryptic Pydantic traceback, this function catches\n    validation errors and prints clear instructions on what's missing and\n    how to fix it.\n    \"\"\"\n    try:\n        return Settings()\n    except ValidationError as e:\n        missing_fields = []\n        invalid_fields = []\n\n        for error in e.errors():\n            field_name = str(error['loc'][0]) if error['loc'] else 'unknown'\n            error_type = error['type']\n            error_msg = error.get('msg', '')\n\n            if error_type == 'missing':\n                missing_fields.append(field_name)\n            else:\n                # Extract a user-friendly message\n                if 'value_error' in error_type or 'string' in error_type:\n                    invalid_fields.append((field_name, error_msg))\n                else:\n                    invalid_fields.append((field_name, f\"{error_type}: {error_msg}\"))\n\n        print_config_error(missing_fields, invalid_fields)\n        sys.exit(1)\n\n\n# Global settings instance\nsettings = load_settings()\n